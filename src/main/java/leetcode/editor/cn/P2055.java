//////////////////////给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 0 开始的字符串 s ，它只包含字符 '*' 和 '|' 
//，其
////中 
//////'*
////////' 
//////////表示
////////////一个
////////////// 盘
////////////////子 
//////////////////，
////////////////////'|
//////////////////////' 表示一支 蜡烛 。 
//////////////////////
////////////////////// 同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, 
//////righti] 
////////表示
////////// 子
////////////字符
//////////////串 
////////////////s[
//////////////////
//////////////////////lefti...righti] （包含左右端点的字符）。对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘
//子的
//// 数
//////目 
////////。如
//////////果一
////////////个盘
//////////////子在
//////////////// 子
//////////////////字符
////////////////////串中 左边和右边
////////////////////// 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。 
//////////////////////
////////////////////// 
////////////////////// 比方说，s = "||**||**|*" ，查询 [3, 8] ，表示的是子字符串 "*||**|" 。子字符串中
//在两
////支蜡
//////烛之
////////间的
//////////盘子
////////////数目
//////////////为 
////////////////2 
//////////////////，子
////////////////////字符
//////////////////////串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。 
////////////////////// 
//////////////////////
////////////////////// 请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。 
//////////////////////
////////////////////// 
//////////////////////
////////////////////// 示例 1: 
//////////////////////
////////////////////// 
//////////////////////
////////////////////// 输入：s = "**|**|***|", queries = [[2,5],[5,9]]
//////////////////////输出：[2,3]
//////////////////////解释：
//////////////////////- queries[0] 有两个盘子在蜡烛之间。
//////////////////////- queries[1] 有三个盘子在蜡烛之间。
////////////////////// 
//////////////////////
////////////////////// 示例 2: 
//////////////////////
////////////////////// 
//////////////////////
////////////////////// 输入：s = "***|**|*****|**||**|*", queries = [[1,17],[4,5],[
//14
////,1
//////7]
////////,[
//////////5,
////////////11
//////////////],
////////////////[1
//////////////////5,
////////////////////16
//////////////////////]]
//////////////////////输出：[9,0,0,0,0]
//////////////////////解释：
//////////////////////- queries[0] 有 9 个盘子在蜡烛之间。
//////////////////////- 另一个查询没有盘子在蜡烛之间。
////////////////////// 
//////////////////////
////////////////////// 
//////////////////////
////////////////////// 提示： 
//////////////////////
////////////////////// 
////////////////////// 3 <= s.length <= 10⁵ 
////////////////////// s 只包含字符 '*' 和 '|' 。 
////////////////////// 1 <= queries.length <= 10⁵ 
////////////////////// queries[i].length == 2 
////////////////////// 0 <= lefti <= righti < s.length 
////////////////////// 
////////////////////// Related Topics 数组 字符串 二分查找 前缀和 👍 70 👎 0
////////////////////
//////////////////
////////////////
//////////////
////////////
//////////
////////
//////
////
//


package leetcode.editor.cn;

import javafx.util.Pair;

import java.util.Arrays;
import java.util.Objects;

//Java：蜡烛之间的盘子
public class P2055 {
    public static void main(String[] args) {
        Solution solution = new P2055().new Solution();
        // TO TEST
        int[][] ints = {{2, 5}, {5, 9}};
        ;

        System.out.println(Arrays.toString(solution.platesBetweenCandles("**|**|***|", ints)));
        System.out.println(Arrays.toString(solution.platesBetweenCandles("***|**|*****|**||**|*", new int[][]{{1, 17}, {4, 5}, {14, 17}, {5, 11}, {15, 16}})));
    }

    //leetcode submit region begin(Prohibit modification and deletion)
    class Solution {
        public int[] platesBetweenCandles(String s, int[][] queries) {
            int length = s.length();
            // key是左边最近的一个盘子，默认是-1， value是右边， 默认是-1
            Pair[] dp = new Pair[length];

            // 记录从[0,i]中间有几个蜡烛
            int[] midnum = new int[length];

            int[] result = new int[queries.length];


            // 右边
            int now = -1;
            int num = 0;
            for (int i = 0; i < length; i++) {
                if (s.charAt(i) == '|') {
                    now = i;
                    num++;
                }
                dp[i] = new Pair(now, -1);
                midnum[i] = num;
            }

            // 左边
            now = -1;
            for (int i = length - 1; i >= 0; i--) {
                if (s.charAt(i) == '|') {
                    now = i;
                }
                dp[i] = new Pair(dp[i].getKey(), now);
            }

            for (int i = 0; i < queries.length; i++) {
                int left = (int) dp[queries[i][0]].getValue();
                int right = (int) dp[queries[i][1]].getKey();
                if(left == -1 || right == -1 || right <= left){
                    result[i] = 0;
                    continue;
                }
                // i-j -(i~j中间有几个盘子)
                result[i] = right - left - (midnum[right] - midnum[left]);
            }

            return result;
        }

    }
//leetcode submit region end(Prohibit modification and deletion)
}
